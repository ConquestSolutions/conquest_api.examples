// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// ConquestAPIGeoPackageTableDescription A description of one table that exists in a geopackage
//
// swagger:model conquest_apiGeoPackageTableDescription
type ConquestAPIGeoPackageTableDescription struct {

	// ColumnInfos
	ColumnInfos []*ConquestApigpkgColumnInfo `json:"ColumnInfos"`

	// Contents describes what tables have geometry data and the projection in use
	Contents *ConquestApigpkgContents `json:"Contents,omitempty"`

	// DataColumns are what could be identified in a geo package for a table.
	DataColumns []*ConquestApigpkgDataColumns `json:"DataColumns"`

	// GeometryColumn is the geometry column that will be used. There can only be one of these per table.
	GeometryColumn *ConquestApigpkgGeometryColumns `json:"GeometryColumn,omitempty"`

	// GeometryColumns are what could be identified in a geo package for a table.
	// There can only be one of these per table.
	GeometryColumns []*ConquestApigpkgGeometryColumns `json:"GeometryColumns"`

	// KeyColumnOption are user provided options that specify what column should be used as a key
	KeyColumnOption *ConquestAPIGeoPackageKeyColumnDescriptionOption `json:"KeyColumnOption,omitempty"`

	// ObjectIDColumn is the identity column that will be used to key the data to a Conquest Object
	//
	// This is identified by either the KeyColumnOption otherwise a it will be inferred based on
	// a naming convention for Conquest IDs like asset_id or by annotated columns in DataColumns
	ObjectIDColumn *ConquestApigpkgColumnInfo `json:"ObjectIDColumn,omitempty"`

	// ObjectType that will be used to key data to the Conquest Object.
	//
	// This is identified by either the KeyColumnOption otherwise a it will be inferred based on
	// a naming convention for Conquest IDs like asset_id or by annotated columns in DataColumns
	ObjectType *ConquestAPIObjectType `json:"ObjectType,omitempty"`

	// SRSSupported specifies whether the provided Spatial Reference System can be processed
	SrsSupported bool `json:"SrsSupported,omitempty"`

	// TableName of the table that's being described
	TableName string `json:"TableName,omitempty"`
}

// Validate validates this conquest api geo package table description
func (m *ConquestAPIGeoPackageTableDescription) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateColumnInfos(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateContents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeometryColumn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGeometryColumns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKeyColumnOption(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectIDColumn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateObjectType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) validateColumnInfos(formats strfmt.Registry) error {
	if swag.IsZero(m.ColumnInfos) { // not required
		return nil
	}

	for i := 0; i < len(m.ColumnInfos); i++ {
		if swag.IsZero(m.ColumnInfos[i]) { // not required
			continue
		}

		if m.ColumnInfos[i] != nil {
			if err := m.ColumnInfos[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ColumnInfos" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ColumnInfos" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) validateContents(formats strfmt.Registry) error {
	if swag.IsZero(m.Contents) { // not required
		return nil
	}

	if m.Contents != nil {
		if err := m.Contents.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Contents")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("Contents")
			}
			return err
		}
	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) validateDataColumns(formats strfmt.Registry) error {
	if swag.IsZero(m.DataColumns) { // not required
		return nil
	}

	for i := 0; i < len(m.DataColumns); i++ {
		if swag.IsZero(m.DataColumns[i]) { // not required
			continue
		}

		if m.DataColumns[i] != nil {
			if err := m.DataColumns[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("DataColumns" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("DataColumns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) validateGeometryColumn(formats strfmt.Registry) error {
	if swag.IsZero(m.GeometryColumn) { // not required
		return nil
	}

	if m.GeometryColumn != nil {
		if err := m.GeometryColumn.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("GeometryColumn")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("GeometryColumn")
			}
			return err
		}
	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) validateGeometryColumns(formats strfmt.Registry) error {
	if swag.IsZero(m.GeometryColumns) { // not required
		return nil
	}

	for i := 0; i < len(m.GeometryColumns); i++ {
		if swag.IsZero(m.GeometryColumns[i]) { // not required
			continue
		}

		if m.GeometryColumns[i] != nil {
			if err := m.GeometryColumns[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("GeometryColumns" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("GeometryColumns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) validateKeyColumnOption(formats strfmt.Registry) error {
	if swag.IsZero(m.KeyColumnOption) { // not required
		return nil
	}

	if m.KeyColumnOption != nil {
		if err := m.KeyColumnOption.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("KeyColumnOption")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("KeyColumnOption")
			}
			return err
		}
	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) validateObjectIDColumn(formats strfmt.Registry) error {
	if swag.IsZero(m.ObjectIDColumn) { // not required
		return nil
	}

	if m.ObjectIDColumn != nil {
		if err := m.ObjectIDColumn.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ObjectIDColumn")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ObjectIDColumn")
			}
			return err
		}
	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) validateObjectType(formats strfmt.Registry) error {
	if swag.IsZero(m.ObjectType) { // not required
		return nil
	}

	if m.ObjectType != nil {
		if err := m.ObjectType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ObjectType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ObjectType")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this conquest api geo package table description based on the context it is used
func (m *ConquestAPIGeoPackageTableDescription) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateColumnInfos(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateContents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDataColumns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeometryColumn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateGeometryColumns(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateKeyColumnOption(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObjectIDColumn(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateObjectType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) contextValidateColumnInfos(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ColumnInfos); i++ {

		if m.ColumnInfos[i] != nil {
			if err := m.ColumnInfos[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ColumnInfos" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ColumnInfos" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) contextValidateContents(ctx context.Context, formats strfmt.Registry) error {

	if m.Contents != nil {
		if err := m.Contents.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("Contents")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("Contents")
			}
			return err
		}
	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) contextValidateDataColumns(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DataColumns); i++ {

		if m.DataColumns[i] != nil {
			if err := m.DataColumns[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("DataColumns" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("DataColumns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) contextValidateGeometryColumn(ctx context.Context, formats strfmt.Registry) error {

	if m.GeometryColumn != nil {
		if err := m.GeometryColumn.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("GeometryColumn")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("GeometryColumn")
			}
			return err
		}
	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) contextValidateGeometryColumns(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.GeometryColumns); i++ {

		if m.GeometryColumns[i] != nil {
			if err := m.GeometryColumns[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("GeometryColumns" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("GeometryColumns" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) contextValidateKeyColumnOption(ctx context.Context, formats strfmt.Registry) error {

	if m.KeyColumnOption != nil {
		if err := m.KeyColumnOption.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("KeyColumnOption")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("KeyColumnOption")
			}
			return err
		}
	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) contextValidateObjectIDColumn(ctx context.Context, formats strfmt.Registry) error {

	if m.ObjectIDColumn != nil {
		if err := m.ObjectIDColumn.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ObjectIDColumn")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ObjectIDColumn")
			}
			return err
		}
	}

	return nil
}

func (m *ConquestAPIGeoPackageTableDescription) contextValidateObjectType(ctx context.Context, formats strfmt.Registry) error {

	if m.ObjectType != nil {
		if err := m.ObjectType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ObjectType")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ObjectType")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ConquestAPIGeoPackageTableDescription) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConquestAPIGeoPackageTableDescription) UnmarshalBinary(b []byte) error {
	var res ConquestAPIGeoPackageTableDescription
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
